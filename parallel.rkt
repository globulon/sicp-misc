#lang scheme
(require racket/mpair)

(define (make-mutex) 
  (let ((cell (mlist false)))
    (define (test-and-set! cell)
      (display (mcar cell))
      (if (mcar cell)
          true
          (begin
            (set-mcar! cell true)
            false)))
    (define (release cell)
      (set-mcar! cell false))
    (define (dispatch m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (dispatch 'acquire)
                 'acquired))
            ((eq? m 'release)
             (release cell))))
    dispatch))

(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (procedure)
      (define (serialized-procedure . args)
        (mutex 'acquire)
        (let ((val (apply procedure args)))
          (mutex 'release)
          val))
      serialized-procedure)))

;with mutexes
(define (make-semaphore-1 max)
  (let ((mutex (make-mutex))
        (lock-number max))
    (define (inc n) (+ n 1))
    (define (dec n) (- n 1))
    (define (release)
      (mutex ' acquire)
      (unless (= max lock-number)
        (set! lock-number (inc lock-number)))
      (mutex 'release))
    (define (acquire)
      (mutex ' acquire)
      (cond ((= lock-number 0)
             (mutex 'release)
             (acquire))
            ((> lock-number 0)
             (set! lock-number (dec lock-number))
             (mutex 'release))
            (else
             (error "inconsistent state of semaphore"))))
    (define (dispatch m)
      (cond ((= 'acquire) (acquire))
            ((= 'release) (release))))
    dispatch))

(define (make-semaphore-2 max)
  (let ((cell (mlist false))
        (lock-number max))
    (define (inc n) (+ n 1))
    (define (dec n) (- n 1))
    (define (test-and-set! cell)
      (if (mcar cell)
          true
          (begin
            (set-mcar! cell true)
            false)))
    (define (wait-on cell)
      (if (test-and-set! cell)
          (wait-on cell)
          false))
    (define (release cell)
      (set-mcar! cell false))
    (define (lock)
      (wait-on cell)
      (cond ((= lock-number 0)
             (release cell)
             (lock))
            ((> lock-number 0)
             (set! lock-number (dec lock-number))
             (release cell))
            (else
             (error "inconsistent state of semaphore"))))
    (define (unlock)
      (wait-on cell)
      (unless (= max lock-number)
        (set! lock-number (inc lock-number)))
      (release cell))
    (define (dispatch m)
      (cond ((= 'acquire) (lock))
            ((= 'release) (unlock))))
    dispatch))

(define (make-account amount identifier)
  (let ((serializer (make-serializer))
        (balance amount)
        (id identifier))
    (define (deposit amount)
      (display "depositing...")
      (newline)
      (set! balance (+ balance amount)))
    (define (withdraw amount)
      (if (> balance amount)
          (set! balance (- balance amount))
          (error "not enough funds to withdraw" (list balance amount))))
    (define (dispatch m)
      (cond ((eq? m 'deposit) (serializer deposit))
            ((eq? m 'withdraw) (serializer withdraw))
            ((eq? m 'get-amount) balance)
            ((eq? m 'get-id) id)
            ((eq? m 'serializer) serializer)
            (else 
             (error "unknown command"))))
    dispatch))

;((an-amount 'deposit) 50)
(define (exchange a b)
  (let ((diff (- (b 'get-amount) (a 'get-amount))))
    (cond ((> diff 0)
           ((a 'deposit) diff)
           ((b' withdraw) diff))
          (else 
           ((a 'withdraw) (- diff))
           ((b' deposit) (- diff))))))

(define (serialized-exchange a b)
  (let ((id-a (a 'get-id))
        (id-b (b 'get-id)))
    (let ((serializer1 ((if (> id-b id-a) a b) 'serializer))
          (serializer2 ((if (> id-b id-a) b a) 'serializer)))
      ((serializer1 (serializer2 exchange)) a b))))

(define a (make-account 100 1))
(define b (make-account 150 2))
